---
layout: base
title: Die deutsche Seite zum Elixir-Framework
description: Alles rund um Phoenix/Elixir auf deutsch - Tutorials · Artikel · News · Workshops.
permalink: /
---

<div class="container">
  <main role="main">
    <br>
    <br>
    <br>
    <h1 class="text-center mt-4">
      <img src="/assets/img/phoenixframework-de-logo.svg" alt="PhoenixFramework.de", class="mb-4">
      <br>
      News, Artikel und Kurse zum Phoenix-Framework
    </h1>

    <hr>

    <br>

    <h2>Die neusten Artikel</h2>

    <div class="row">
      <div class="col-md-6">
      {% for post in site.posts %}
        {% include _article.html %}
      {% endfor %}
      </div>
    </div>

    <br>

    <h2>Wie es zu dieser Seite kam</h2>

    <div class="col-count-2">
      <p>
        Alle Programmiersprachen und Frameworks sind gleich. Kein Problem, denken viele - Schon falsch.
        Letztendlich werden zwar alle Sprachen später zu Machinen-Code. Aber der Startpunkt spielt schon eine
        große Rolle. 2015 waren wir dabei eine Community-Seite (wie diese) umzubauen. Wir wollten eine
        Plattform bauen, um mehrere Community-Seiten einfach verwalten zu können.
      </p>
      <p>
        Unser Framework damals war Ruby On Rails - und wir waren Rails-Fans.
        Einer unserer Programmierer war schon seit Anfang an dabei und
        hatte schon knapp 10 Jahre Erfahrung mit dem Framework. Mit keinem uns bekannten Framework konnte
        man so schnell neue Funktionalitäten erstellen. Wir waren bis dahin glücklich.
      </p>
      <p>
        Dann fing der Schmerz an, den andere Rails-Entwickler auch kennen. Rails hat starke Konventionen.
        Diese Konventionen nicht einzuhalten, schimpft sich "Gegen das Framework arbeiten". Als wir dann
        anfingen von einer Seite zu mehreren Community-Seiten, mussten wir immer mehr genau das tun.
        Mehrere Domains funktionieren zwar in Rails, aber die Aufteilung in eine zentrale Verwaltungsseite
        und mehrere Community-Seiten bereitete Schmerzen.
      </p>
      <p>
        Obwohl wir eine wirklich gute Testabdeckung hatten, mussten wir natürlich dabei auch viele Tests abändern. Viele Fehler fanden wir dabei erst in Produktion.
        Dabei waren es immer ähnliche Fehler. Z.B. Teile im Html, die nur unter bestimmten Bedingungen angezeigt wurden.
        Manchmal war es dabei auch einfach zeitraubend, Bugs nachzuvollziehen. Rails besteht aus viel
        Magic, um mit wenig Code viel erreichen zu können.
      </p>
      <p>
        Letztendlich machte uns diese Magic nicht immer schneller. Statt den Code in voller länger zu
        schreiben, haben wir mit gleichem Zeitaufwand die Dokumentation gewälzt. Bei Funktionalitäten,
        die nicht unterstützt wurden, stellten wir Pull-Requests auf GitHub. In manchen Fällen wurde
        es auch richtig unschön und wir nutzen als letzte Instanz *Monkey Patching*.
      </p>
      <p>
        Für Interaktivität, wie einen Chat, gab es damals noch keine Lösung in Rails. Erste Lösungen
        benutzten zusätzlich Redis. Wir wollten aber möglichst nicht mehr Komplexität als nötig,
        durch neue externe Tools mit einbauen.
      </p>
      <p>
        Irgendwas stimmte also nicht. Wir suchten also nach einer Lösung. Wir schauten uns JavaScript auf
        Server-Seite an. Allerdings waren die meisten Frameworks eher auf die API-Entwicklung spezialisiert.
        Aber kein Framework stach besonders hervor. Für Java kam Spring in Frage. Mit Java sehr gute,
        stabile Anwendungen bauen. Aber nachdem man Ruby länger programmiert hat, fühlt sich in Java
        also sehr sehr schwerfällig an. Wir hielten uns Java als letzten Ausweg offen, aber gaben
        uns nochmal ein wenig Zeit, um eine Lösung zu finden.
      </p>
      <p>
        Wir stießen dann glücklicherweise auf Elixir und Phoenix. Natürlich war der ersten Verkaufspunkt,
        dass ein ehemaliger Rails-Entwickler die Sprache Elixir entwickelt hatte.
        Aber die Probleme, die die Sprache lösen sollte, sprachen uns an. Geschwindigkeit, Nachvollziehbarkeit,
        Optionale Typisierung. Für uns übersetzt bedeutete das erstmal: Weniger Caching und damit verbundene Fehler,
        schnelle Fehlerbehebung und Vermeidung von super einfachen Tests (weil der Compiler simple Fehler findet).
      </p>
      <p>
        Ohne jetzt stundenlange Lobhymnen auf Elixir und Phoenix zu halten - was wir uns erhofft hatten, wurde mehr als erfüllt.
        Wir hatten natürlich eine Umlernphase, in der nicht alles rosig war. Dies war uns aber auch vorher
        schon bewusst. Mittlerweile treten echte Fehler innerhalb unserer Anwendung nicht mehr auf. Wenn
        Fehler auftreten, sind es Dinge, die vorher schon konzeptionell nicht optimal waren. Oder Probleme
        mit externen Schnittstellen.
      </p>
      <p>
        Unsere Geschwindigkeit für neue Funktionalitäten ist gleich geblieben.
        Refaktorisierung ist extrem angenehm geworden. Durch die Kapselung in Module geht dies in sehr
        kleinen Schritten. Somit haben wir jederzeit eine lauffähige Version. Wir sind auf sehr
        viel weniger externe Pakete angewiesen. Viele Dinge lassen sich sehr kompakt und gut lesbar
        durch Pattern Matching aufschreiben. Wir sind rundum glücklich mit der Wahl.
      </p>
      <p>
        Um mehr Entwicklern eine Zukunft ohne Stress zu ermöglichen, haben wir deshalb diese
        deutsche Seite zum Elixir-Framework gestartet. Euch erwarten News, Artikel und Kurse zum Phoenix-Framework.
      </p>
      <p>
        Wenn du bis hierhin gekommen bist - Vielen Dank für's Lesen! Hast du selbst ähnliche
        Erfahrungen gemacht? Schreib doch gerne einen Artikel darüber und wir veröffentlichen
        ihn hier. Vielleicht magst du auch einfach nur Hallo sagen. Schick eine
        <a href="mailto:sascha.brink@workshops.de">Mail an Sascha</a>.
      </p>
    </div>
    <p>
      <a href="{{site.repository_url}}/edit/master/{{page.path}}" target="_blank">Diese Seite auf GitHub verbessern</a>
    </p>
  </main>
</div>



